export function websocketLogger (server, storage) {
  /*
     Log to web socket server.
  */
  let socket;
  let state = new Set();
  const queue = new Queue('websocketLogger');

  function newWebsocket () {
    socket = new WebSocket(server);
    socket.onopen = prepareSocket;
    socket.onerror = function (e) {
      console.log('Could not connect');
      let event = { issue: 'Could not connect' };
      // event = add_event_metadata('warning', event)
      event = JSON.stringify(event);
      queue.enqueue(event);
    }
    socket.onclose = function (e) {
      console.log('Lost connection');
      let event = { issue: 'Lost connection', code: e.code };
      // event = add_event_metadata('warning', event)
      event = JSON.stringify(event);
      queue.enqueue(event);
    }
    socket.onmessage = receiveMessage;
    return socket;
  }

  socket = newWebsocket();

  function areWeDone () {
    console.log('are we done yet?');
    if (state.has('chrome_identity') &&
      state.has('local_storage') &&
      state.has('allow') &&
      !state.has('ready')) {
      console.log('inside if in arewedone');
      let event = {};
      // const source = 'test.source'
      // const version = '0.0.1'
      // event = defaultEventMetadata({ source, version })
      event = { browser_id: 'node', session_id: 'sid', logger_id: 'lid' };
      socket.send(JSON.stringify(event));
      state.add('ready');
      dequeue();
    } else if (state.has('deny')) {
      socket.close();
    }
  }

  function prepareSocket () {
    // Send the server the user info. This might not always be available.
    state = new Set();
    let event;
    profileInfoWrapper().then((userInfo) => {
      event = {
        chrome_identity: userInfo
      };
      socket.send(JSON.stringify(event));
      console.log('resolving profileInfoWrapper', event);
      state.add('chrome_identity');
      areWeDone();
    })
    const storageKeys = [
      'teacher_tag', // Unused. In the future: whom do we authorize to receive data?
      'user_tag', // Unique per-user tag in the settings page
      'process_server', // Unused. Which server should we send to?
      'unique_id', // Unique ID set in the settings page
      'generated_id', // Autogenerated, for future forensics
      'opt_out'
    ];
    storage.get(storageKeys, function (result) {
      if (result !== undefined) {
        event = { local_storage: result }
      } else {
        event = { local_storage: {} }
      }
      /* if("generated_id" not in event['local_storage']){
          event['local_storage']['generated_id'] = unique_id();
          storage.set(
              'generated_id',
              event['local_storage']['generated_id']
          );
      } */
      if ('opt_out' in event.local_storage) {
        console.log('Opted out');
        socket.close();
      } else {
        console.log(event);
        // event = add_event_metadata('local_storage', event)
        socket.send(JSON.stringify(event)); // do we need this to send right here, we aren't fully ready
        state.add('local_storage');
        areWeDone();
      }
    })
  }

  function receiveMessage (event) {
    const response = JSON.parse(event.data);

    switch (response.status) {
      case 'allow':
        state.add('allow');
        break
      case 'deny':
        state.add('deny');
        // TODO handle any deny status
        break
      default:
        console.log('auth has not yet occured');
        break;
    }
    areWeDone();
  }

  async function dequeue () {
    console.log('dequeuing');
    if (socket === null) {
      // Do nothing. We're reconnecting.
      console.log('Event squelched; reconnecting');
    } else if (socket.readyState === socket.OPEN &&
      state.has('ready')) {
      console.log('sending messages in queue', queue.count());
      while (await queue.count() > 0) {
        const event = await queue.dequeue();
        console.log('about to send', event.value);
        socket.send(event.value); /* TODO: We should do receipt confirmation before dropping events */
      }
    } else if ((socket.readyState === socket.CLOSED) || (socket.readyState === socket.CLOSING)) {
      /*
        If we lost the connection, we wait a second and try to open it again.

        Note that while socket is `null` or `CONNECTING`, we don't take either
        branch -- we just queue up events. We reconnect after 1 second if closed,
        or dequeue events if open.
      */
      console.log('Re-opening connection in 1s');
      socket = null;
      state = new Set();
      await delay(1000);
      console.log('Re-opening connection');
      socket = newWebsocket();
    }
  }

  return function (data) {
    console.log('queue data', data);
    queue.enqueue(data);
    dequeue();
  }
}
