/*
  Logging library for Learning Observer clients
*/

import WebSocket from 'ws'
import { profileInfoWrapper, delay, defaultEventMetadata } from './util.js'
import { Queue } from './queue.js'

// init() has not yet been called. Enqueue events, but don't send them on to
// loggers.
const INIT_FALSE = false
// init() has been called, but is still waiting on e.g. async metadata
const INIT_INPROGRESS = 'init_inprogress'
// init() is done. Note that not all loggers might be ready to send events,
// but they are ready to enqueue events. Most loggers will have
// local queues
const INIT_READY = 'init_ready'
let initialized = INIT_FALSE

// To do: Define and set debug levels
const VERBOSE = 'verbose'
const NONE = 'none'
const debugLogLevel = VERBOSE

// A list of all loggers which should receive events.
const loggers = []
// This can either be:
// * dictionaries of metadata
// * functions which return metadata
// * asynchronous functions which return metadata
const metadata = []
const blocked = false

// TODO: We should consider specifying a set of verbs, nouns, etc. we
// might use, and outlining what can be expected in the protocol
export function init (
  source,
  version,
  loggers,
  metadata,
  debug_level
) {
  initialized = INIT_INPROGRESS
  dequeue()
}

export function logEvent (eventType, event) {
}

export function consoleLogger () {
  /*
  Log to browser JavaScript console
  */
  return console.log
}

export function websocketLogger (server, storage) {
  /*
     Log to web socket server.
  */
  let socket
  let state = new Set()
  const queue = new Queue('websocketLogger')

  function newWebsocket () {
    socket = new WebSocket(server)
    socket.onopen = prepareSocket
    socket.onerror = function (e) {
      console.log('Could not connect')
      let event = { issue: 'Could not connect' }
      // event = add_event_metadata('warning', event)
      event = JSON.stringify(event)
      queue.enqueue(event)
    }
    socket.onclose = function (e) {
      console.log('Lost connection')
      let event = { issue: 'Lost connection', code: e.code }
      // event = add_event_metadata('warning', event)
      event = JSON.stringify(event)
      queue.enqueue(event)
    }
    socket.onmessage = receiveMessage
    return socket
  }

  socket = newWebsocket()

  function areWeDone () {
    console.log('are we done yet?')
    if (state.has('chrome_identity') &&
      state.has('local_storage') &&
      state.has('allow') &&
      !state.has('ready')) {
      console.log('inside if in arewedone')
      let event = {}
      // const source = 'test.source'
      // const version = '0.0.1'
      // event = defaultEventMetadata({ source, version })
      event = { browser_id: 'node', session_id: 'sid', logger_id: 'lid' }
      socket.send(JSON.stringify(event))
      state.add('ready')
      dequeue()
    } else if (state.has('deny')) {
      socket.close()
    }
  }

  function prepareSocket () {
    // Send the server the user info. This might not always be available.
    state = new Set()
    let event
    profileInfoWrapper().then((userInfo) => {
      event = {
        chrome_identity: userInfo
      }
      socket.send(JSON.stringify(event))
      console.log('resolving profileInfoWrapper', event)
      state.add('chrome_identity')
      areWeDone()
    })
    const storageKeys = [
      'teacher_tag', // Unused. In the future: whom do we authorize to receive data?
      'user_tag', // Unique per-user tag in the settings page
      'process_server', // Unused. Which server should we send to?
      'unique_id', // Unique ID set in the settings page
      'generated_id', // Autogenerated, for future forensics
      'opt_out'
    ]
    storage.get(storageKeys, function (result) {
      if (result !== undefined) {
        event = { local_storage: result }
      } else {
        event = { local_storage: {} }
      }
      /* if("generated_id" not in event['local_storage']){
          event['local_storage']['generated_id'] = unique_id();
          storage.set(
              'generated_id',
              event['local_storage']['generated_id']
          );
      } */
      if ('opt_out' in event.local_storage) {
        console.log('Opted out')
        socket.close()
      } else {
        console.log(event)
        // event = add_event_metadata('local_storage', event)
        socket.send(JSON.stringify(event)) // do we need this to send right here, we aren't fully ready
        state.add('local_storage')
        areWeDone()
      }
    })
  }

  function receiveMessage (event) {
    const response = JSON.parse(event.data)

    switch (response.status) {
      case 'allow':
        state.add('allow')
        break
      case 'deny':
        state.add('deny')
        // TODO handle any deny status
        break
      default:
        console.log('auth has not yet occured')
        break
    }
    areWeDone()
  }

  async function dequeue () {
    console.log('dequeuing')
    if (socket === null) {
      // Do nothing. We're reconnecting.
      console.log('Event squelched; reconnecting')
    } else if (socket.readyState === socket.OPEN &&
      state.has('ready')) {
      console.log('sending messages in queue', queue.count())
      while (await queue.count() > 0) {
        const event = await queue.dequeue()
        console.log('about to send', event.value)
        socket.send(event.value) /* TODO: We should do receipt confirmation before dropping events */
      }
    } else if ((socket.readyState === socket.CLOSED) || (socket.readyState === socket.CLOSING)) {
      /*
        If we lost the connection, we wait a second and try to open it again.

        Note that while socket is `null` or `CONNECTING`, we don't take either
        branch -- we just queue up events. We reconnect after 1 second if closed,
        or dequeue events if open.
      */
      console.log('Re-opening connection in 1s')
      socket = null
      state = new Set()
      await delay(1000)
      console.log('Re-opening connection')
      socket = newWebsocket()
    }
  }

  return function (data) {
    console.log('queue data', data)
    queue.enqueue(data)
    dequeue()
  }
}

// storage mirrors the capability of `chrome.storage.sync`
const storage = {
  data: {},
  set: function (items, callback) {
    this.data = { ...this.data, ...items }
    if (callback) callback()
  },
  get: function (keys, callback) {
    let result = {}
    if (Array.isArray(keys)) {
      keys.forEach(key => {
        if (this.data.hasOwnProperty(key)) {
          result[key] = this.data[key]
        }
      })
    } else if (typeof keys === 'string') {
      if (this.data.hasOwnProperty(keys)) {
        result[keys] = this.data[keys]
      }
    } else {
      result = { ...this.data }
    }
    if (callback) callback(result)
  }
}

// const log = websocketLogger('http://127.0.0.1:8765/ws', storage)
// log('test')
// log('123')
